# HG changeset patch
# User Andrew Osmond <aosmond@mozilla.com>
# Date 1475075501 14400
#      Wed Sep 28 11:11:41 2016 -0400
# Node ID 6794567d5ada22acb51afc9c949673b13fd281da
# Parent  1661fbc97f7a5c5dd248907dce5c404409a30bc1
Bug 1294490 - Part 6. Detect WebP MIME type from content sniffing.

diff --git a/image/imgLoader.cpp b/image/imgLoader.cpp
--- a/image/imgLoader.cpp
+++ b/image/imgLoader.cpp
@@ -2510,16 +2510,21 @@ imgLoader::GetMimeTypeFromContent(const 
     aContentType.AssignLiteral(IMAGE_BMP);
 
   // ICOs always begin with a 2-byte 0 followed by a 2-byte 1.
   // CURs begin with 2-byte 0 followed by 2-byte 2.
   } else if (aLength >= 4 && (!memcmp(aContents, "\000\000\001\000", 4) ||
                               !memcmp(aContents, "\000\000\002\000", 4))) {
     aContentType.AssignLiteral(IMAGE_ICO);
 
+  // WebPs always begin with RIFF, a 32-bit length, and WEBP.
+  } else if (aLength >= 12 && !memcmp(aContents, "RIFF", 4) &&
+                              !memcmp(aContents + 8, "WEBP", 4)) {
+    aContentType.AssignLiteral(IMAGE_WEBP);
+
   } else {
     /* none of the above?  I give up */
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return NS_OK;
 }
 
diff --git a/image/test/gtest/TestLoader.cpp b/image/test/gtest/TestLoader.cpp
new file mode 100644
--- /dev/null
+++ b/image/test/gtest/TestLoader.cpp
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "gtest/gtest.h"
+
+#include "Common.h"
+#include "imgLoader.h"
+#include "nsMimeTypes.h"
+#include "nsString.h"
+
+using namespace mozilla;
+using namespace mozilla::image;
+
+static void
+CheckMimeType(const char* aContents, size_t aLength, const char* aExpected)
+{
+  nsAutoCString detected;
+  nsresult rv = imgLoader::GetMimeTypeFromContent(aContents, aLength, detected);
+  if (aExpected) {
+    ASSERT_TRUE(NS_SUCCEEDED(rv));
+    EXPECT_TRUE(detected.EqualsASCII(aExpected));
+  } else {
+    ASSERT_TRUE(NS_FAILED(rv));
+    EXPECT_TRUE(detected.IsEmpty());
+  }
+}
+
+class ImageLoader : public ::testing::Test
+{
+protected:
+  AutoInitializeImageLib mInit;
+};
+
+TEST_F(ImageLoader, DetectGIF)
+{
+  const char buffer[] = "GIF87a";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_GIF);
+}
+
+TEST_F(ImageLoader, DetectPNG)
+{
+  const char buffer[] = "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_PNG);
+}
+
+TEST_F(ImageLoader, DetectJPEG)
+{
+  const char buffer[] = "\xFF\xD8\xFF";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_JPEG);
+}
+
+TEST_F(ImageLoader, DetectART)
+{
+  const char buffer[] = "\x4A\x47\xFF\xFF\x00";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_ART);
+}
+
+TEST_F(ImageLoader, DetectBMP)
+{
+  const char buffer[] = "BM";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_BMP);
+}
+
+TEST_F(ImageLoader, DetectICO)
+{
+  const char buffer[] = "\x00\x00\x01\x00";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_ICO);
+}
+
+TEST_F(ImageLoader, DetectWebP)
+{
+  const char buffer[] = "RIFF\xFF\xFF\xFF\xFFWEBPVP8L";
+  CheckMimeType(buffer, sizeof(buffer), IMAGE_WEBP);
+}
+
+TEST_F(ImageLoader, DetectNone)
+{
+  const char buffer[] = "abcdefghijklmnop";
+  CheckMimeType(buffer, sizeof(buffer), nullptr);
+}
+
diff --git a/image/test/gtest/moz.build b/image/test/gtest/moz.build
--- a/image/test/gtest/moz.build
+++ b/image/test/gtest/moz.build
@@ -8,16 +8,17 @@ Library('imagetest')
 
 UNIFIED_SOURCES = [
     'Common.cpp',
     'TestADAM7InterpolatingFilter.cpp',
     'TestCopyOnWrite.cpp',
     'TestDecoders.cpp',
     'TestDecodeToSurface.cpp',
     'TestDeinterlacingFilter.cpp',
+    'TestLoader.cpp',
     'TestMetadata.cpp',
     'TestRemoveFrameRectFilter.cpp',
     'TestSourceBuffer.cpp',
     'TestStreamingLexer.cpp',
     'TestSurfaceSink.cpp',
 ]
 
 if CONFIG['MOZ_ENABLE_SKIA']:
