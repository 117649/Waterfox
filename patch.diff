# HG changeset patch
# User Andrew Osmond <aosmond@mozilla.com>
# Date 1475075503 14400
#      Wed Sep 28 11:11:43 2016 -0400
# Node ID 0d8b74fd87e38fac90fe8ccb48cabefa24c51c25
# Parent  403dddedc43d7244989d98e944bcc5bef2e0369c
Bug 1294490 - Part 7. Implement WebP tests.

diff --git a/image/test/gtest/Common.cpp b/image/test/gtest/Common.cpp
--- a/image/test/gtest/Common.cpp
+++ b/image/test/gtest/Common.cpp
@@ -510,28 +510,39 @@ ImageTestCase GreenICOTestCase()
 }
 
 ImageTestCase GreenIconTestCase()
 {
   return ImageTestCase("green.icon", "image/icon", IntSize(100, 100),
                        TEST_CASE_IS_TRANSPARENT);
 }
 
+ImageTestCase GreenWebPTestCase()
+{
+  return ImageTestCase("green.webp", "image/webp", IntSize(100, 100));
+}
+
 ImageTestCase GreenFirstFrameAnimatedGIFTestCase()
 {
   return ImageTestCase("first-frame-green.gif", "image/gif", IntSize(100, 100),
                        TEST_CASE_IS_ANIMATED);
 }
 
 ImageTestCase GreenFirstFrameAnimatedPNGTestCase()
 {
   return ImageTestCase("first-frame-green.png", "image/png", IntSize(100, 100),
                        TEST_CASE_IS_TRANSPARENT | TEST_CASE_IS_ANIMATED);
 }
 
+ImageTestCase GreenFirstFrameAnimatedWebPTestCase()
+{
+  return ImageTestCase("first-frame-green.webp", "image/webp", IntSize(100, 100),
+                       TEST_CASE_IS_ANIMATED);
+}
+
 ImageTestCase CorruptTestCase()
 {
   return ImageTestCase("corrupt.jpg", "image/jpeg", IntSize(100, 100),
                        TEST_CASE_HAS_ERROR);
 }
 
 ImageTestCase CorruptBMPWithTruncatedHeader()
 {
@@ -658,16 +669,22 @@ ImageTestCase DownscaledICOTestCase()
 }
 
 ImageTestCase DownscaledIconTestCase()
 {
   return ImageTestCase("downscaled.icon", "image/icon", IntSize(100, 100),
                        IntSize(20, 20), TEST_CASE_IS_TRANSPARENT);
 }
 
+ImageTestCase DownscaledWebPTestCase()
+{
+  return ImageTestCase("downscaled.webp", "image/webp", IntSize(100, 100),
+                       IntSize(20, 20));
+}
+
 ImageTestCase DownscaledTransparentICOWithANDMaskTestCase()
 {
   // This test case is an ICO with AND mask transparency. We want to ensure that
   // we can downscale it without crashing or triggering ASAN failures, but its
   // content isn't simple to verify, so for now we don't check the output.
   return ImageTestCase("transparent-ico-with-and-mask.ico", "image/x-icon",
                        IntSize(32, 32), IntSize(20, 20),
                        TEST_CASE_IS_TRANSPARENT | TEST_CASE_IGNORE_OUTPUT);
diff --git a/image/test/gtest/Common.h b/image/test/gtest/Common.h
--- a/image/test/gtest/Common.h
+++ b/image/test/gtest/Common.h
@@ -109,16 +109,18 @@ struct BGRAColor
  */
 struct AutoInitializeImageLib
 {
   AutoInitializeImageLib()
   {
     // Ensure that ImageLib services are initialized.
     nsCOMPtr<imgITools> imgTools = do_CreateInstance("@mozilla.org/image/tools;1");
     EXPECT_TRUE(imgTools != nullptr);
+    nsresult rv = Preferences::SetBool("image.webp.enabled", true);
+    EXPECT_TRUE(rv == NS_OK);
   }
 };
 
 /// Loads a file from the current directory. @return an nsIInputStream for it.
 already_AddRefed<nsIInputStream> LoadFile(const char* aRelativePath);
 
 /**
  * @returns true if every pixel of @aSurface is @aColor.
@@ -379,19 +381,21 @@ void CheckPalettedWritePixels(Decoder* a
 ///////////////////////////////////////////////////////////////////////////////
 
 ImageTestCase GreenPNGTestCase();
 ImageTestCase GreenGIFTestCase();
 ImageTestCase GreenJPGTestCase();
 ImageTestCase GreenBMPTestCase();
 ImageTestCase GreenICOTestCase();
 ImageTestCase GreenIconTestCase();
+ImageTestCase GreenWebPTestCase();
 
 ImageTestCase GreenFirstFrameAnimatedGIFTestCase();
 ImageTestCase GreenFirstFrameAnimatedPNGTestCase();
+ImageTestCase GreenFirstFrameAnimatedWebPTestCase();
 
 ImageTestCase CorruptTestCase();
 ImageTestCase CorruptBMPWithTruncatedHeader();
 ImageTestCase CorruptICOWithBadBMPWidthTestCase();
 ImageTestCase CorruptICOWithBadBMPHeightTestCase();
 ImageTestCase CorruptICOWithBadBppTestCase();
 
 ImageTestCase TransparentPNGTestCase();
@@ -405,16 +409,17 @@ ImageTestCase RLE4BMPTestCase();
 ImageTestCase RLE8BMPTestCase();
 
 ImageTestCase DownscaledPNGTestCase();
 ImageTestCase DownscaledGIFTestCase();
 ImageTestCase DownscaledJPGTestCase();
 ImageTestCase DownscaledBMPTestCase();
 ImageTestCase DownscaledICOTestCase();
 ImageTestCase DownscaledIconTestCase();
+ImageTestCase DownscaledWebPTestCase();
 ImageTestCase DownscaledTransparentICOWithANDMaskTestCase();
 
 ImageTestCase TruncatedSmallGIFTestCase();
 
 } // namespace image
 } // namespace mozilla
 
 #endif // mozilla_image_test_gtest_Common_h
diff --git a/image/test/gtest/TestDecodeToSurface.cpp b/image/test/gtest/TestDecodeToSurface.cpp
--- a/image/test/gtest/TestDecodeToSurface.cpp
+++ b/image/test/gtest/TestDecodeToSurface.cpp
@@ -92,16 +92,17 @@ protected:
 };
 
 TEST_F(ImageDecodeToSurface, PNG) { RunDecodeToSurface(GreenPNGTestCase()); }
 TEST_F(ImageDecodeToSurface, GIF) { RunDecodeToSurface(GreenGIFTestCase()); }
 TEST_F(ImageDecodeToSurface, JPG) { RunDecodeToSurface(GreenJPGTestCase()); }
 TEST_F(ImageDecodeToSurface, BMP) { RunDecodeToSurface(GreenBMPTestCase()); }
 TEST_F(ImageDecodeToSurface, ICO) { RunDecodeToSurface(GreenICOTestCase()); }
 TEST_F(ImageDecodeToSurface, Icon) { RunDecodeToSurface(GreenIconTestCase()); }
+TEST_F(ImageDecodeToSurface, WebP) { RunDecodeToSurface(GreenWebPTestCase()); }
 
 TEST_F(ImageDecodeToSurface, AnimatedGIF)
 {
   RunDecodeToSurface(GreenFirstFrameAnimatedGIFTestCase());
 }
 
 TEST_F(ImageDecodeToSurface, AnimatedPNG)
 {
diff --git a/image/test/gtest/TestDecoders.cpp b/image/test/gtest/TestDecoders.cpp
--- a/image/test/gtest/TestDecoders.cpp
+++ b/image/test/gtest/TestDecoders.cpp
@@ -198,16 +198,245 @@ CheckDownscaleDuringDecode(const ImageTe
     // small amount of fuzz; this is just the nature of Lanczos downscaling.
     EXPECT_TRUE(RowsAreSolidColor(surface, 0, 4, BGRAColor::Green(), /* aFuzz = */ 47));
     EXPECT_TRUE(RowsAreSolidColor(surface, 6, 3, BGRAColor::Red(), /* aFuzz = */ 27));
     EXPECT_TRUE(RowsAreSolidColor(surface, 11, 3, BGRAColor::Green(), /* aFuzz = */ 47));
     EXPECT_TRUE(RowsAreSolidColor(surface, 16, 4, BGRAColor::Red(), /* aFuzz = */ 27));
   });
 }
 
+static void
+CheckDecoderFrameFirst(const ImageTestCase& aTestCase)
+{
+  // Verify that we can decode this test case and retrieve the first frame using
+  // imgIContainer::FRAME_FIRST. This ensures that we correctly trigger a
+  // single-frame decode rather than an animated decode when
+  // imgIContainer::FRAME_FIRST is requested.
+
+  // Create an image.
+  RefPtr<Image> image =
+    ImageFactory::CreateAnonymousImage(nsDependentCString(aTestCase.mMimeType));
+  ASSERT_TRUE(!image->HasError());
+
+  nsCOMPtr<nsIInputStream> inputStream = LoadFile(aTestCase.mPath);
+  ASSERT_TRUE(inputStream);
+
+  // Figure out how much data we have.
+  uint64_t length;
+  nsresult rv = inputStream->Available(&length);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  // Write the data into the image.
+  rv = image->OnImageDataAvailable(nullptr, nullptr, inputStream, 0,
+                                   static_cast<uint32_t>(length));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  // Let the image know we've sent all the data.
+  rv = image->OnImageDataComplete(nullptr, nullptr, NS_OK, true);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  RefPtr<ProgressTracker> tracker = image->GetProgressTracker();
+  tracker->SyncNotifyProgress(FLAG_LOAD_COMPLETE);
+
+  // Lock the image so its surfaces don't disappear during the test.
+  image->LockImage();
+
+  // Use GetFrame() to force a sync decode of the image, specifying FRAME_FIRST
+  // to ensure that we don't get an animated decode.
+  RefPtr<SourceSurface> surface =
+    image->GetFrame(imgIContainer::FRAME_FIRST,
+                    imgIContainer::FLAG_SYNC_DECODE);
+
+  // Ensure that the image's metadata meets our expectations.
+  IntSize imageSize(0, 0);
+  rv = image->GetWidth(&imageSize.width);
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+  rv = image->GetHeight(&imageSize.height);
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+
+  EXPECT_EQ(aTestCase.mSize.width, imageSize.width);
+  EXPECT_EQ(aTestCase.mSize.height, imageSize.height);
+
+  Progress imageProgress = tracker->GetProgress();
+
+  EXPECT_TRUE(bool(imageProgress & FLAG_HAS_TRANSPARENCY) == false);
+  EXPECT_TRUE(bool(imageProgress & FLAG_IS_ANIMATED) == true);
+
+  // Ensure that we decoded the static version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eStatic));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+
+  // Ensure that we didn't decode the animated version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eAnimated));
+    ASSERT_EQ(MatchType::NOT_FOUND, result.Type());
+  }
+
+  // Use GetFrame() to force a sync decode of the image, this time specifying
+  // FRAME_CURRENT to ensure that we get an animated decode.
+  RefPtr<SourceSurface> animatedSurface =
+    image->GetFrame(imgIContainer::FRAME_CURRENT,
+                    imgIContainer::FLAG_SYNC_DECODE);
+
+  // Ensure that we decoded both frames of the animated version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eAnimated));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
+    EXPECT_TRUE(bool(result.Surface()));
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+
+  // Ensure that the static version is still around.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eStatic));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+}
+
+static void
+CheckDecoderFrameCurrent(const ImageTestCase& aTestCase)
+{
+  // Verify that we can decode this test case and retrieve the entire sequence
+  // of frames using imgIContainer::FRAME_CURRENT. This ensures that we
+  // correctly trigger an animated decode rather than a single-frame decode when
+  // imgIContainer::FRAME_CURRENT is requested.
+
+  // Create an image.
+  RefPtr<Image> image =
+    ImageFactory::CreateAnonymousImage(nsDependentCString(aTestCase.mMimeType));
+  ASSERT_TRUE(!image->HasError());
+
+  nsCOMPtr<nsIInputStream> inputStream = LoadFile(aTestCase.mPath);
+  ASSERT_TRUE(inputStream);
+
+  // Figure out how much data we have.
+  uint64_t length;
+  nsresult rv = inputStream->Available(&length);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  // Write the data into the image.
+  rv = image->OnImageDataAvailable(nullptr, nullptr, inputStream, 0,
+                                   static_cast<uint32_t>(length));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  // Let the image know we've sent all the data.
+  rv = image->OnImageDataComplete(nullptr, nullptr, NS_OK, true);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  RefPtr<ProgressTracker> tracker = image->GetProgressTracker();
+  tracker->SyncNotifyProgress(FLAG_LOAD_COMPLETE);
+
+  // Lock the image so its surfaces don't disappear during the test.
+  image->LockImage();
+
+  // Use GetFrame() to force a sync decode of the image, specifying
+  // FRAME_CURRENT to ensure we get an animated decode.
+  RefPtr<SourceSurface> surface =
+    image->GetFrame(imgIContainer::FRAME_CURRENT,
+                    imgIContainer::FLAG_SYNC_DECODE);
+
+  // Ensure that the image's metadata meets our expectations.
+  IntSize imageSize(0, 0);
+  rv = image->GetWidth(&imageSize.width);
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+  rv = image->GetHeight(&imageSize.height);
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+
+  EXPECT_EQ(aTestCase.mSize.width, imageSize.width);
+  EXPECT_EQ(aTestCase.mSize.height, imageSize.height);
+
+  Progress imageProgress = tracker->GetProgress();
+
+  EXPECT_TRUE(bool(imageProgress & FLAG_HAS_TRANSPARENCY) == false);
+  EXPECT_TRUE(bool(imageProgress & FLAG_IS_ANIMATED) == true);
+
+  // Ensure that we decoded both frames of the animated version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eAnimated));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
+    EXPECT_TRUE(bool(result.Surface()));
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+
+  // Ensure that we didn't decode the static version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eStatic));
+    ASSERT_EQ(MatchType::NOT_FOUND, result.Type());
+  }
+
+  // Use GetFrame() to force a sync decode of the image, this time specifying
+  // FRAME_FIRST to ensure that we get a single-frame decode.
+  RefPtr<SourceSurface> animatedSurface =
+    image->GetFrame(imgIContainer::FRAME_FIRST,
+                    imgIContainer::FLAG_SYNC_DECODE);
+
+  // Ensure that we decoded the static version of the image.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eStatic));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+
+  // Ensure that both frames of the animated version are still around.
+  {
+    LookupResult result =
+      SurfaceCache::Lookup(ImageKey(image.get()),
+                           RasterSurfaceKey(imageSize,
+                                            DefaultSurfaceFlags(),
+                                            PlaybackType::eAnimated));
+    ASSERT_EQ(MatchType::EXACT, result.Type());
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
+    EXPECT_TRUE(bool(result.Surface()));
+
+    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
+    EXPECT_TRUE(bool(result.Surface()));
+  }
+}
+
 class ImageDecoders : public ::testing::Test
 {
 protected:
   AutoInitializeImageLib mInit;
 };
 
 TEST_F(ImageDecoders, PNGSingleChunk)
 {
@@ -299,16 +528,31 @@ TEST_F(ImageDecoders, IconMultiChunk)
   CheckDecoderMultiChunk(GreenIconTestCase());
 }
 
 TEST_F(ImageDecoders, IconDownscaleDuringDecode)
 {
   CheckDownscaleDuringDecode(DownscaledIconTestCase());
 }
 
+TEST_F(ImageDecoders, WebPSingleChunk)
+{
+  CheckDecoderSingleChunk(GreenWebPTestCase());
+}
+
+TEST_F(ImageDecoders, WebPMultiChunk)
+{
+  CheckDecoderMultiChunk(GreenWebPTestCase());
+}
+
+TEST_F(ImageDecoders, WebPDownscaleDuringDecode)
+{
+  CheckDownscaleDuringDecode(DownscaledWebPTestCase());
+}
+
 TEST_F(ImageDecoders, AnimatedGIFSingleChunk)
 {
   CheckDecoderSingleChunk(GreenFirstFrameAnimatedGIFTestCase());
 }
 
 TEST_F(ImageDecoders, AnimatedGIFMultiChunk)
 {
   CheckDecoderMultiChunk(GreenFirstFrameAnimatedGIFTestCase());
@@ -319,16 +563,26 @@ TEST_F(ImageDecoders, AnimatedPNGSingleC
   CheckDecoderSingleChunk(GreenFirstFrameAnimatedPNGTestCase());
 }
 
 TEST_F(ImageDecoders, AnimatedPNGMultiChunk)
 {
   CheckDecoderMultiChunk(GreenFirstFrameAnimatedPNGTestCase());
 }
 
+TEST_F(ImageDecoders, AnimatedWebPSingleChunk)
+{
+  CheckDecoderSingleChunk(GreenFirstFrameAnimatedWebPTestCase());
+}
+
+TEST_F(ImageDecoders, AnimatedWebPMultiChunk)
+{
+  CheckDecoderMultiChunk(GreenFirstFrameAnimatedWebPTestCase());
+}
+
 TEST_F(ImageDecoders, CorruptSingleChunk)
 {
   CheckDecoderSingleChunk(CorruptTestCase());
 }
 
 TEST_F(ImageDecoders, CorruptMultiChunk)
 {
   CheckDecoderMultiChunk(CorruptTestCase());
@@ -366,243 +620,22 @@ TEST_F(ImageDecoders, CorruptICOWithBadB
 
 TEST_F(ImageDecoders, CorruptICOWithBadBppSingleChunk)
 {
   CheckDecoderSingleChunk(CorruptICOWithBadBppTestCase());
 }
 
 TEST_F(ImageDecoders, AnimatedGIFWithFRAME_FIRST)
 {
-  ImageTestCase testCase = GreenFirstFrameAnimatedGIFTestCase();
-
-  // Verify that we can decode this test case and retrieve the first frame using
-  // imgIContainer::FRAME_FIRST. This ensures that we correctly trigger a
-  // single-frame decode rather than an animated decode when
-  // imgIContainer::FRAME_FIRST is requested.
-
-  // Create an image.
-  RefPtr<Image> image =
-    ImageFactory::CreateAnonymousImage(nsDependentCString(testCase.mMimeType));
-  ASSERT_TRUE(!image->HasError());
-
-  nsCOMPtr<nsIInputStream> inputStream = LoadFile(testCase.mPath);
-  ASSERT_TRUE(inputStream);
-
-  // Figure out how much data we have.
-  uint64_t length;
-  nsresult rv = inputStream->Available(&length);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  // Write the data into the image.
-  rv = image->OnImageDataAvailable(nullptr, nullptr, inputStream, 0,
-                                   static_cast<uint32_t>(length));
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  // Let the image know we've sent all the data.
-  rv = image->OnImageDataComplete(nullptr, nullptr, NS_OK, true);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  RefPtr<ProgressTracker> tracker = image->GetProgressTracker();
-  tracker->SyncNotifyProgress(FLAG_LOAD_COMPLETE);
-
-  // Lock the image so its surfaces don't disappear during the test.
-  image->LockImage();
-
-  // Use GetFrame() to force a sync decode of the image, specifying FRAME_FIRST
-  // to ensure that we don't get an animated decode.
-  RefPtr<SourceSurface> surface =
-    image->GetFrame(imgIContainer::FRAME_FIRST,
-                    imgIContainer::FLAG_SYNC_DECODE);
-
-  // Ensure that the image's metadata meets our expectations.
-  IntSize imageSize(0, 0);
-  rv = image->GetWidth(&imageSize.width);
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-  rv = image->GetHeight(&imageSize.height);
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-  EXPECT_EQ(testCase.mSize.width, imageSize.width);
-  EXPECT_EQ(testCase.mSize.height, imageSize.height);
-
-  Progress imageProgress = tracker->GetProgress();
-
-  EXPECT_TRUE(bool(imageProgress & FLAG_HAS_TRANSPARENCY) == false);
-  EXPECT_TRUE(bool(imageProgress & FLAG_IS_ANIMATED) == true);
-
-  // Ensure that we decoded the static version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eStatic));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-    EXPECT_TRUE(bool(result.Surface()));
-  }
-
-  // Ensure that we didn't decode the animated version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eAnimated));
-    ASSERT_EQ(MatchType::NOT_FOUND, result.Type());
-  }
-
-  // Use GetFrame() to force a sync decode of the image, this time specifying
-  // FRAME_CURRENT to ensure that we get an animated decode.
-  RefPtr<SourceSurface> animatedSurface =
-    image->GetFrame(imgIContainer::FRAME_CURRENT,
-                    imgIContainer::FLAG_SYNC_DECODE);
-
-  // Ensure that we decoded both frames of the animated version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eAnimated));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
-    EXPECT_TRUE(bool(result.Surface()));
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
-    EXPECT_TRUE(bool(result.Surface()));
-  }
-
-  // Ensure that the static version is still around.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eStatic));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-    EXPECT_TRUE(bool(result.Surface()));
-  }
+  CheckDecoderFrameFirst(GreenFirstFrameAnimatedGIFTestCase());
 }
 
 TEST_F(ImageDecoders, AnimatedGIFWithFRAME_CURRENT)
 {
-  ImageTestCase testCase = GreenFirstFrameAnimatedGIFTestCase();
-
-  // Verify that we can decode this test case and retrieve the entire sequence
-  // of frames using imgIContainer::FRAME_CURRENT. This ensures that we
-  // correctly trigger an animated decode rather than a single-frame decode when
-  // imgIContainer::FRAME_CURRENT is requested.
-
-  // Create an image.
-  RefPtr<Image> image =
-    ImageFactory::CreateAnonymousImage(nsDependentCString(testCase.mMimeType));
-  ASSERT_TRUE(!image->HasError());
-
-  nsCOMPtr<nsIInputStream> inputStream = LoadFile(testCase.mPath);
-  ASSERT_TRUE(inputStream);
-
-  // Figure out how much data we have.
-  uint64_t length;
-  nsresult rv = inputStream->Available(&length);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  // Write the data into the image.
-  rv = image->OnImageDataAvailable(nullptr, nullptr, inputStream, 0,
-                                   static_cast<uint32_t>(length));
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  // Let the image know we've sent all the data.
-  rv = image->OnImageDataComplete(nullptr, nullptr, NS_OK, true);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
-
-  RefPtr<ProgressTracker> tracker = image->GetProgressTracker();
-  tracker->SyncNotifyProgress(FLAG_LOAD_COMPLETE);
-
-  // Lock the image so its surfaces don't disappear during the test.
-  image->LockImage();
-
-  // Use GetFrame() to force a sync decode of the image, specifying
-  // FRAME_CURRENT to ensure we get an animated decode.
-  RefPtr<SourceSurface> surface =
-    image->GetFrame(imgIContainer::FRAME_CURRENT,
-                    imgIContainer::FLAG_SYNC_DECODE);
-
-  // Ensure that the image's metadata meets our expectations.
-  IntSize imageSize(0, 0);
-  rv = image->GetWidth(&imageSize.width);
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-  rv = image->GetHeight(&imageSize.height);
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-  EXPECT_EQ(testCase.mSize.width, imageSize.width);
-  EXPECT_EQ(testCase.mSize.height, imageSize.height);
-
-  Progress imageProgress = tracker->GetProgress();
-
-  EXPECT_TRUE(bool(imageProgress & FLAG_HAS_TRANSPARENCY) == false);
-  EXPECT_TRUE(bool(imageProgress & FLAG_IS_ANIMATED) == true);
-
-  // Ensure that we decoded both frames of the animated version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eAnimated));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
-    EXPECT_TRUE(bool(result.Surface()));
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
-    EXPECT_TRUE(bool(result.Surface()));
-  }
-
-  // Ensure that we didn't decode the static version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eStatic));
-    ASSERT_EQ(MatchType::NOT_FOUND, result.Type());
-  }
-
-  // Use GetFrame() to force a sync decode of the image, this time specifying
-  // FRAME_FIRST to ensure that we get a single-frame decode.
-  RefPtr<SourceSurface> animatedSurface =
-    image->GetFrame(imgIContainer::FRAME_FIRST,
-                    imgIContainer::FLAG_SYNC_DECODE);
-
-  // Ensure that we decoded the static version of the image.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eStatic));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-    EXPECT_TRUE(bool(result.Surface()));
-  }
-
-  // Ensure that both frames of the animated version are still around.
-  {
-    LookupResult result =
-      SurfaceCache::Lookup(ImageKey(image.get()),
-                           RasterSurfaceKey(imageSize,
-                                            DefaultSurfaceFlags(),
-                                            PlaybackType::eAnimated));
-    ASSERT_EQ(MatchType::EXACT, result.Type());
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
-    EXPECT_TRUE(bool(result.Surface()));
-
-    EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
-    EXPECT_TRUE(bool(result.Surface()));
-  }
+  CheckDecoderFrameCurrent(GreenFirstFrameAnimatedGIFTestCase());
 }
 
 TEST_F(ImageDecoders, AnimatedGIFWithExtraImageSubBlocks)
 {
   ImageTestCase testCase = ExtraImageSubBlocksAnimatedGIFTestCase();
 
   // Verify that we can decode this test case and get two frames, even though
   // there are extra image sub blocks between the first and second frame. The
@@ -663,12 +696,22 @@ TEST_F(ImageDecoders, AnimatedGIFWithExt
 
   EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(0)));
   EXPECT_TRUE(bool(result.Surface()));
 
   EXPECT_TRUE(NS_SUCCEEDED(result.Surface().Seek(1)));
   EXPECT_TRUE(bool(result.Surface()));
 }
 
+TEST_F(ImageDecoders, AnimatedWebPWithFRAME_FIRST)
+{
+  CheckDecoderFrameFirst(GreenFirstFrameAnimatedWebPTestCase());
+}
+
+TEST_F(ImageDecoders, AnimatedWebPWithFRAME_CURRENT)
+{
+  CheckDecoderFrameCurrent(GreenFirstFrameAnimatedWebPTestCase());
+}
+
 TEST_F(ImageDecoders, TruncatedSmallGIFSingleChunk)
 {
   CheckDecoderSingleChunk(TruncatedSmallGIFTestCase());
 }
diff --git a/image/test/gtest/TestMetadata.cpp b/image/test/gtest/TestMetadata.cpp
--- a/image/test/gtest/TestMetadata.cpp
+++ b/image/test/gtest/TestMetadata.cpp
@@ -142,16 +142,17 @@ protected:
 TEST_F(ImageDecoderMetadata, PNG) { CheckMetadata(GreenPNGTestCase()); }
 TEST_F(ImageDecoderMetadata, TransparentPNG) { CheckMetadata(TransparentPNGTestCase()); }
 TEST_F(ImageDecoderMetadata, GIF) { CheckMetadata(GreenGIFTestCase()); }
 TEST_F(ImageDecoderMetadata, TransparentGIF) { CheckMetadata(TransparentGIFTestCase()); }
 TEST_F(ImageDecoderMetadata, JPG) { CheckMetadata(GreenJPGTestCase()); }
 TEST_F(ImageDecoderMetadata, BMP) { CheckMetadata(GreenBMPTestCase()); }
 TEST_F(ImageDecoderMetadata, ICO) { CheckMetadata(GreenICOTestCase()); }
 TEST_F(ImageDecoderMetadata, Icon) { CheckMetadata(GreenIconTestCase()); }
+TEST_F(ImageDecoderMetadata, WebP) { CheckMetadata(GreenWebPTestCase()); }
 
 TEST_F(ImageDecoderMetadata, AnimatedGIF)
 {
   CheckMetadata(GreenFirstFrameAnimatedGIFTestCase());
 }
 
 TEST_F(ImageDecoderMetadata, AnimatedPNG)
 {
diff --git a/image/test/gtest/downscaled.webp b/image/test/gtest/downscaled.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..c2db6d6446b5524579a094b7276d721e7b160087
GIT binary patch
literal 56
zc$^FJbaOLcU|<M$bqWXzu<%g<vh|Y>NHFkk`2Sh{v%F}>mfU9v|E|uH<#+p1&y-QI
L{qBVidAk__@n{v=

diff --git a/image/test/gtest/first-frame-green.webp b/image/test/gtest/first-frame-green.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..44db5c71c374086aaf00054c19bd269c50acc41c
GIT binary patch
literal 154
zc$^FJbaR`;z`zjh>J$(bU=hIuWHSMAG8j4fdHS*ec?|!75Xkd&(_?@Eh>8@Ta-cpR
zQJ{!^@&O43_6z?z{;@Z-e5l_qaPfbL5?Gf3rY;7ME^&me{r|qM|IetP_~*X9%NP5p
G91H+?{UqlA

diff --git a/image/test/gtest/green.webp b/image/test/gtest/green.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..04b7f003b463948d248755c4d6b19567941f8781
GIT binary patch
literal 42
wc$^FJbaPW;U|<M$bqWXzu<#KDvh|Y>NHDNp_}}r5y`kkp{eFRq|3j1*0P(*L3;+NC

diff --git a/image/test/gtest/moz.build b/image/test/gtest/moz.build
--- a/image/test/gtest/moz.build
+++ b/image/test/gtest/moz.build
@@ -39,26 +39,29 @@ TEST_HARNESS_FILES.gtest += [
     'corrupt-with-bad-ico-bpp.ico',
     'corrupt.jpg',
     'downscaled.bmp',
     'downscaled.gif',
     'downscaled.ico',
     'downscaled.icon',
     'downscaled.jpg',
     'downscaled.png',
+    'downscaled.webp',
     'first-frame-green.gif',
     'first-frame-green.png',
+    'first-frame-green.webp',
     'first-frame-padding.gif',
     'green-1x1-truncated.gif',
     'green.bmp',
     'green.gif',
     'green.ico',
     'green.icon',
     'green.jpg',
     'green.png',
+    'green.webp',
     'invalid-truncated-metadata.bmp',
     'no-frame-delay.gif',
     'rle4.bmp',
     'rle8.bmp',
     'transparent-ico-with-and-mask.ico',
     'transparent-if-within-ico.bmp',
     'transparent.gif',
     'transparent.png',
diff --git a/image/test/mochitest/clear.webp b/image/test/mochitest/clear.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..6db376d6e176f94b8d152f491a779370b3ea45bc
GIT binary patch
literal 202
zc$^FJbaOkzz`zjh>J$(bU=hIuWD5atG8j4fdHS*edH;cc5y<m((_w%Ch>8>j1}30B
zA7P+~e)0hc0d@gFK?b2i|NlC<{15H~>(Rs1!vNAF3f05FF7UViAA3W~hx+{j7ypMS
Hk!2GA*Dx&M

diff --git a/image/test/mochitest/clear2.webp b/image/test/mochitest/clear2.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..e4a3e2efabe2c963cd186dcd064dd1fd139aa7ab
GIT binary patch
literal 228
zc$^FJbaT7Iz`zjh>J$(bU=hIuWD5atG6RDb1B0WVr!O0j_a6utfjnO~Jq8$nr~s;G
z0_yV-1&Zh=HwZDXU-;kgkG-Mg!~cCk7yoaO1naWGp-Ty>OMqYCv;1dy9@kuH!>9eL
z&Uhu<sc`*L&-B4d^KEB7$OH?ZN<Ib#VK9<Km>>@_LD+#^fZyQ1AlQW44iEWv{gsn$
O==kT)ps;@e3j+YMkvPu)

diff --git a/image/test/mochitest/keep.webp b/image/test/mochitest/keep.webp
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..342982be06630473c1b83cba69eec5324adc5869
GIT binary patch
literal 152
zc$^FJbaR`)z`zjh>J$(bU=hIuWHSMAG8j4fdHS*edH;cc5y<m((_?@Eh>8@Ta-cpR
qQJ{!^@&O43c7ebB|JWN^KGg3QxcEOr39GIXKo+X53;#P%bO8Y7!6n@Q

diff --git a/image/test/mochitest/mochitest.ini b/image/test/mochitest/mochitest.ini
--- a/image/test/mochitest/mochitest.ini
+++ b/image/test/mochitest/mochitest.ini
@@ -39,33 +39,36 @@ support-files =
   bug1132427.gif
   bug1180105.sjs
   bug1180105-waiter.sjs
   bug1217571-iframe.html
   bug1319025.png
   bug1319025-ref.png
   clear.gif
   clear.png
+  clear.webp
   clear2.gif
+  clear2.webp
   clear2-results.gif
   damon.jpg
   error-early.png
   filter-final.svg
   filter.svg
   first-frame-padding.gif
   green.png
   green-background.html
   grey.png
   ico-bmp-opaque.ico
   ico-bmp-transparent.ico
   iframe.html
   imgutils.js
   invalid.jpg
   keep.gif
   keep.png
+  keep.webp
   lime100x100.svg
   lime-anim-100x100.svg
   lime-anim-100x100-2.svg
   lime-css-anim-100x100.svg
   opaque.bmp
   purple.gif
   red.gif
   red.png
diff --git a/image/test/mochitest/test_animation_operators.html b/image/test/mochitest/test_animation_operators.html
--- a/image/test/mochitest/test_animation_operators.html
+++ b/image/test/mochitest/test_animation_operators.html
@@ -24,33 +24,36 @@ https://bugzilla.mozilla.org/show_bug.cg
 // (Note that we do _not_ poll the reference, so it must not be animated.)
 
 var gTests = [
   // IMPORTANT NOTE: For these tests, the test and reference are not
   // snapshotted in the same way.  The REFERENCE (second file) is
   // assumed to be complete when loaded, but we poll the TEST
   // (first file) until the test passes.
 
-  // Tests of the allowed disposal operators for both GIF and APNG: keep, clear,
+  // Tests of the allowed disposal operators for GIF, APNG and WebP: keep, clear,
   // and restore previous.
   "== green-background.html?clear.gif green.png",
   "== green-background.html?clear.png green.png",
+  "== green-background.html?clear.webp green.png",
   "== keep.gif green.png",
   "== keep.png green.png",
+  "== keep.webp green.png",
   "== restore-previous.gif green.png",
   "== restore-previous.png green.png",
 
   // Tests of the blending/compositing operators that only APNG supports.
   "== over.png grey.png",
   "!= source.png grey.png",
   "== bug900200.png bug900200-ref.png",
   "== bug1319025.png bug1319025-ref.png",
 
   // Test of subframe updates.
   "== clear2.gif clear2-results.gif",
+  "== clear2.webp clear2-results.gif",
 ];
 
 // Maintain a reference count of how many things we're waiting for until
 // we can say the tests are done.
 var gDelayCount = 0;
 function AddFinishDependency()
   { ++gDelayCount; }
 function RemoveFinishDependency()
@@ -140,20 +143,25 @@ function startTest(i)
     return iframe;
   }
 
   AddFinishDependency();
   var test = startIframe(testData.test);
   var reference = startIframe(testData.reference);
 }
 
+function runTests()
+{
+  // Run the tests.
+  for (var i = 0; i < gTests.length; ++i) {
+    startTest(i);
+  }
+}
+
 SimpleTest.waitForExplicitFinish();
 SimpleTest.requestFlakyTimeout("untriaged");
 
-// Run the tests.
-for (var i = 0; i < gTests.length; ++i) {
-  startTest(i);
-}
+SpecialPowers.pushPrefEnv({"set": [["image.webp.enabled", true]]}, runTests);
 
 </script>
 </pre>
 </body>
 </html>
